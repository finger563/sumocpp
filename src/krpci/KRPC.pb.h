// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: KRPC.proto

#ifndef PROTOBUF_KRPC_2eproto__INCLUDED
#define PROTOBUF_KRPC_2eproto__INCLUDED

#include <string>

#include "/usr/include/google/protobuf/stubs/common.h"

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include "/usr/include/google/protobuf/arena.h"
#include "/usr/include/google/protobuf/arenastring.h"
#include "/usr/include/google/protobuf/generated_message_util.h"
#include "/usr/include/google/protobuf/metadata.h"
#include "/usr/include/google/protobuf/message.h"
#include "/usr/include/google/protobuf/repeated_field.h"
#include "/usr/include/google/protobuf/extension_set.h"
#include "/usr/include/google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

namespace krpc {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_KRPC_2eproto();
void protobuf_AssignDesc_KRPC_2eproto();
void protobuf_ShutdownFile_KRPC_2eproto();

class Request;
class Argument;
class Response;
class StreamMessage;
class StreamResponse;
class Services;
class Service;
class Procedure;
class Parameter;
class Class;
class Enumeration;
class EnumerationValue;
class List;
class Dictionary;
class DictionaryEntry;
class Set;
class Tuple;
class Status;

// ===================================================================

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service = 1;
  bool has_service() const;
  void clear_service();
  static const int kServiceFieldNumber = 1;
  const ::std::string& service() const;
  void set_service(const ::std::string& value);
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  ::std::string* mutable_service();
  ::std::string* release_service();
  void set_allocated_service(::std::string* service);

  // required string procedure = 2;
  bool has_procedure() const;
  void clear_procedure();
  static const int kProcedureFieldNumber = 2;
  const ::std::string& procedure() const;
  void set_procedure(const ::std::string& value);
  void set_procedure(const char* value);
  void set_procedure(const char* value, size_t size);
  ::std::string* mutable_procedure();
  ::std::string* release_procedure();
  void set_allocated_procedure(::std::string* procedure);

  // repeated .krpc.Argument arguments = 3;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 3;
  const ::krpc::Argument& arguments(int index) const;
  ::krpc::Argument* mutable_arguments(int index);
  ::krpc::Argument* add_arguments();
  const ::google::protobuf::RepeatedPtrField< ::krpc::Argument >&
      arguments() const;
  ::google::protobuf::RepeatedPtrField< ::krpc::Argument >*
      mutable_arguments();

  // @@protoc_insertion_point(class_scope:krpc.Request)
 private:
  inline void set_has_service();
  inline void clear_has_service();
  inline void set_has_procedure();
  inline void clear_has_procedure();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr service_;
  ::google::protobuf::internal::ArenaStringPtr procedure_;
  ::google::protobuf::RepeatedPtrField< ::krpc::Argument > arguments_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::Message {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Argument& default_instance();

  void Swap(Argument* other);

  // implements Message ----------------------------------------------

  inline Argument* New() const { return New(NULL); }

  Argument* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Argument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // required bytes value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:krpc.Argument)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::uint32 position_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Argument* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  double time() const;
  void set_time(double value);

  // optional string error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // optional bytes return_value = 3;
  bool has_return_value() const;
  void clear_return_value();
  static const int kReturnValueFieldNumber = 3;
  const ::std::string& return_value() const;
  void set_return_value(const ::std::string& value);
  void set_return_value(const char* value);
  void set_return_value(const void* value, size_t size);
  ::std::string* mutable_return_value();
  ::std::string* release_return_value();
  void set_allocated_return_value(::std::string* return_value);

  // @@protoc_insertion_point(class_scope:krpc.Response)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_return_value();
  inline void clear_has_return_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double time_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::internal::ArenaStringPtr return_value_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class StreamMessage : public ::google::protobuf::Message {
 public:
  StreamMessage();
  virtual ~StreamMessage();

  StreamMessage(const StreamMessage& from);

  inline StreamMessage& operator=(const StreamMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamMessage& default_instance();

  void Swap(StreamMessage* other);

  // implements Message ----------------------------------------------

  inline StreamMessage* New() const { return New(NULL); }

  StreamMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamMessage& from);
  void MergeFrom(const StreamMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .krpc.StreamResponse responses = 1;
  int responses_size() const;
  void clear_responses();
  static const int kResponsesFieldNumber = 1;
  const ::krpc::StreamResponse& responses(int index) const;
  ::krpc::StreamResponse* mutable_responses(int index);
  ::krpc::StreamResponse* add_responses();
  const ::google::protobuf::RepeatedPtrField< ::krpc::StreamResponse >&
      responses() const;
  ::google::protobuf::RepeatedPtrField< ::krpc::StreamResponse >*
      mutable_responses();

  // @@protoc_insertion_point(class_scope:krpc.StreamMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::krpc::StreamResponse > responses_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static StreamMessage* default_instance_;
};
// -------------------------------------------------------------------

class StreamResponse : public ::google::protobuf::Message {
 public:
  StreamResponse();
  virtual ~StreamResponse();

  StreamResponse(const StreamResponse& from);

  inline StreamResponse& operator=(const StreamResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamResponse& default_instance();

  void Swap(StreamResponse* other);

  // implements Message ----------------------------------------------

  inline StreamResponse* New() const { return New(NULL); }

  StreamResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamResponse& from);
  void MergeFrom(const StreamResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // required .krpc.Response response = 2;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 2;
  const ::krpc::Response& response() const;
  ::krpc::Response* mutable_response();
  ::krpc::Response* release_response();
  void set_allocated_response(::krpc::Response* response);

  // @@protoc_insertion_point(class_scope:krpc.StreamResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_response();
  inline void clear_has_response();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::krpc::Response* response_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static StreamResponse* default_instance_;
};
// -------------------------------------------------------------------

class Services : public ::google::protobuf::Message {
 public:
  Services();
  virtual ~Services();

  Services(const Services& from);

  inline Services& operator=(const Services& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Services& default_instance();

  void Swap(Services* other);

  // implements Message ----------------------------------------------

  inline Services* New() const { return New(NULL); }

  Services* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Services& from);
  void MergeFrom(const Services& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .krpc.Service services = 1;
  int services_size() const;
  void clear_services();
  static const int kServicesFieldNumber = 1;
  const ::krpc::Service& services(int index) const;
  ::krpc::Service* mutable_services(int index);
  ::krpc::Service* add_services();
  const ::google::protobuf::RepeatedPtrField< ::krpc::Service >&
      services() const;
  ::google::protobuf::RepeatedPtrField< ::krpc::Service >*
      mutable_services();

  // @@protoc_insertion_point(class_scope:krpc.Services)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::krpc::Service > services_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Services* default_instance_;
};
// -------------------------------------------------------------------

class Service : public ::google::protobuf::Message {
 public:
  Service();
  virtual ~Service();

  Service(const Service& from);

  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Service& default_instance();

  void Swap(Service* other);

  // implements Message ----------------------------------------------

  inline Service* New() const { return New(NULL); }

  Service* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Service& from);
  void MergeFrom(const Service& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Service* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .krpc.Procedure procedures = 2;
  int procedures_size() const;
  void clear_procedures();
  static const int kProceduresFieldNumber = 2;
  const ::krpc::Procedure& procedures(int index) const;
  ::krpc::Procedure* mutable_procedures(int index);
  ::krpc::Procedure* add_procedures();
  const ::google::protobuf::RepeatedPtrField< ::krpc::Procedure >&
      procedures() const;
  ::google::protobuf::RepeatedPtrField< ::krpc::Procedure >*
      mutable_procedures();

  // repeated .krpc.Class classes = 3;
  int classes_size() const;
  void clear_classes();
  static const int kClassesFieldNumber = 3;
  const ::krpc::Class& classes(int index) const;
  ::krpc::Class* mutable_classes(int index);
  ::krpc::Class* add_classes();
  const ::google::protobuf::RepeatedPtrField< ::krpc::Class >&
      classes() const;
  ::google::protobuf::RepeatedPtrField< ::krpc::Class >*
      mutable_classes();

  // repeated .krpc.Enumeration enumerations = 4;
  int enumerations_size() const;
  void clear_enumerations();
  static const int kEnumerationsFieldNumber = 4;
  const ::krpc::Enumeration& enumerations(int index) const;
  ::krpc::Enumeration* mutable_enumerations(int index);
  ::krpc::Enumeration* add_enumerations();
  const ::google::protobuf::RepeatedPtrField< ::krpc::Enumeration >&
      enumerations() const;
  ::google::protobuf::RepeatedPtrField< ::krpc::Enumeration >*
      mutable_enumerations();

  // @@protoc_insertion_point(class_scope:krpc.Service)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::krpc::Procedure > procedures_;
  ::google::protobuf::RepeatedPtrField< ::krpc::Class > classes_;
  ::google::protobuf::RepeatedPtrField< ::krpc::Enumeration > enumerations_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Service* default_instance_;
};
// -------------------------------------------------------------------

class Procedure : public ::google::protobuf::Message {
 public:
  Procedure();
  virtual ~Procedure();

  Procedure(const Procedure& from);

  inline Procedure& operator=(const Procedure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Procedure& default_instance();

  void Swap(Procedure* other);

  // implements Message ----------------------------------------------

  inline Procedure* New() const { return New(NULL); }

  Procedure* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Procedure& from);
  void MergeFrom(const Procedure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Procedure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .krpc.Parameter parameters = 2;
  int parameters_size() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 2;
  const ::krpc::Parameter& parameters(int index) const;
  ::krpc::Parameter* mutable_parameters(int index);
  ::krpc::Parameter* add_parameters();
  const ::google::protobuf::RepeatedPtrField< ::krpc::Parameter >&
      parameters() const;
  ::google::protobuf::RepeatedPtrField< ::krpc::Parameter >*
      mutable_parameters();

  // optional string return_type = 3;
  bool has_return_type() const;
  void clear_return_type();
  static const int kReturnTypeFieldNumber = 3;
  const ::std::string& return_type() const;
  void set_return_type(const ::std::string& value);
  void set_return_type(const char* value);
  void set_return_type(const char* value, size_t size);
  ::std::string* mutable_return_type();
  ::std::string* release_return_type();
  void set_allocated_return_type(::std::string* return_type);

  // repeated string attributes = 4;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  const ::std::string& attributes(int index) const;
  ::std::string* mutable_attributes(int index);
  void set_attributes(int index, const ::std::string& value);
  void set_attributes(int index, const char* value);
  void set_attributes(int index, const char* value, size_t size);
  ::std::string* add_attributes();
  void add_attributes(const ::std::string& value);
  void add_attributes(const char* value);
  void add_attributes(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& attributes() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attributes();

  // @@protoc_insertion_point(class_scope:krpc.Procedure)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_return_type();
  inline void clear_has_return_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::krpc::Parameter > parameters_;
  ::google::protobuf::internal::ArenaStringPtr return_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attributes_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Procedure* default_instance_;
};
// -------------------------------------------------------------------

class Parameter : public ::google::protobuf::Message {
 public:
  Parameter();
  virtual ~Parameter();

  Parameter(const Parameter& from);

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();

  void Swap(Parameter* other);

  // implements Message ----------------------------------------------

  inline Parameter* New() const { return New(NULL); }

  Parameter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Parameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional bytes default_argument = 3;
  bool has_default_argument() const;
  void clear_default_argument();
  static const int kDefaultArgumentFieldNumber = 3;
  const ::std::string& default_argument() const;
  void set_default_argument(const ::std::string& value);
  void set_default_argument(const char* value);
  void set_default_argument(const void* value, size_t size);
  ::std::string* mutable_default_argument();
  ::std::string* release_default_argument();
  void set_allocated_default_argument(::std::string* default_argument);

  // @@protoc_insertion_point(class_scope:krpc.Parameter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_default_argument();
  inline void clear_has_default_argument();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr default_argument_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Parameter* default_instance_;
};
// -------------------------------------------------------------------

class Class : public ::google::protobuf::Message {
 public:
  Class();
  virtual ~Class();

  Class(const Class& from);

  inline Class& operator=(const Class& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Class& default_instance();

  void Swap(Class* other);

  // implements Message ----------------------------------------------

  inline Class* New() const { return New(NULL); }

  Class* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Class& from);
  void MergeFrom(const Class& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Class* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:krpc.Class)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Class* default_instance_;
};
// -------------------------------------------------------------------

class Enumeration : public ::google::protobuf::Message {
 public:
  Enumeration();
  virtual ~Enumeration();

  Enumeration(const Enumeration& from);

  inline Enumeration& operator=(const Enumeration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Enumeration& default_instance();

  void Swap(Enumeration* other);

  // implements Message ----------------------------------------------

  inline Enumeration* New() const { return New(NULL); }

  Enumeration* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Enumeration& from);
  void MergeFrom(const Enumeration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Enumeration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .krpc.EnumerationValue values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::krpc::EnumerationValue& values(int index) const;
  ::krpc::EnumerationValue* mutable_values(int index);
  ::krpc::EnumerationValue* add_values();
  const ::google::protobuf::RepeatedPtrField< ::krpc::EnumerationValue >&
      values() const;
  ::google::protobuf::RepeatedPtrField< ::krpc::EnumerationValue >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:krpc.Enumeration)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::krpc::EnumerationValue > values_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Enumeration* default_instance_;
};
// -------------------------------------------------------------------

class EnumerationValue : public ::google::protobuf::Message {
 public:
  EnumerationValue();
  virtual ~EnumerationValue();

  EnumerationValue(const EnumerationValue& from);

  inline EnumerationValue& operator=(const EnumerationValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnumerationValue& default_instance();

  void Swap(EnumerationValue* other);

  // implements Message ----------------------------------------------

  inline EnumerationValue* New() const { return New(NULL); }

  EnumerationValue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnumerationValue& from);
  void MergeFrom(const EnumerationValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnumerationValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:krpc.EnumerationValue)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 value_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static EnumerationValue* default_instance_;
};
// -------------------------------------------------------------------

class List : public ::google::protobuf::Message {
 public:
  List();
  virtual ~List();

  List(const List& from);

  inline List& operator=(const List& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const List& default_instance();

  void Swap(List* other);

  // implements Message ----------------------------------------------

  inline List* New() const { return New(NULL); }

  List* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const List& from);
  void MergeFrom(const List& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::std::string& items(int index) const;
  ::std::string* mutable_items(int index);
  void set_items(int index, const ::std::string& value);
  void set_items(int index, const char* value);
  void set_items(int index, const void* value, size_t size);
  ::std::string* add_items();
  void add_items(const ::std::string& value);
  void add_items(const char* value);
  void add_items(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& items() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_items();

  // @@protoc_insertion_point(class_scope:krpc.List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> items_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static List* default_instance_;
};
// -------------------------------------------------------------------

class Dictionary : public ::google::protobuf::Message {
 public:
  Dictionary();
  virtual ~Dictionary();

  Dictionary(const Dictionary& from);

  inline Dictionary& operator=(const Dictionary& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Dictionary& default_instance();

  void Swap(Dictionary* other);

  // implements Message ----------------------------------------------

  inline Dictionary* New() const { return New(NULL); }

  Dictionary* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Dictionary& from);
  void MergeFrom(const Dictionary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Dictionary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .krpc.DictionaryEntry entries = 1;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 1;
  const ::krpc::DictionaryEntry& entries(int index) const;
  ::krpc::DictionaryEntry* mutable_entries(int index);
  ::krpc::DictionaryEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::krpc::DictionaryEntry >&
      entries() const;
  ::google::protobuf::RepeatedPtrField< ::krpc::DictionaryEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:krpc.Dictionary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::krpc::DictionaryEntry > entries_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Dictionary* default_instance_;
};
// -------------------------------------------------------------------

class DictionaryEntry : public ::google::protobuf::Message {
 public:
  DictionaryEntry();
  virtual ~DictionaryEntry();

  DictionaryEntry(const DictionaryEntry& from);

  inline DictionaryEntry& operator=(const DictionaryEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DictionaryEntry& default_instance();

  void Swap(DictionaryEntry* other);

  // implements Message ----------------------------------------------

  inline DictionaryEntry* New() const { return New(NULL); }

  DictionaryEntry* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DictionaryEntry& from);
  void MergeFrom(const DictionaryEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DictionaryEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required bytes value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:krpc.DictionaryEntry)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static DictionaryEntry* default_instance_;
};
// -------------------------------------------------------------------

class Set : public ::google::protobuf::Message {
 public:
  Set();
  virtual ~Set();

  Set(const Set& from);

  inline Set& operator=(const Set& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Set& default_instance();

  void Swap(Set* other);

  // implements Message ----------------------------------------------

  inline Set* New() const { return New(NULL); }

  Set* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Set& from);
  void MergeFrom(const Set& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Set* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::std::string& items(int index) const;
  ::std::string* mutable_items(int index);
  void set_items(int index, const ::std::string& value);
  void set_items(int index, const char* value);
  void set_items(int index, const void* value, size_t size);
  ::std::string* add_items();
  void add_items(const ::std::string& value);
  void add_items(const char* value);
  void add_items(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& items() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_items();

  // @@protoc_insertion_point(class_scope:krpc.Set)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> items_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Set* default_instance_;
};
// -------------------------------------------------------------------

class Tuple : public ::google::protobuf::Message {
 public:
  Tuple();
  virtual ~Tuple();

  Tuple(const Tuple& from);

  inline Tuple& operator=(const Tuple& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tuple& default_instance();

  void Swap(Tuple* other);

  // implements Message ----------------------------------------------

  inline Tuple* New() const { return New(NULL); }

  Tuple* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tuple& from);
  void MergeFrom(const Tuple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Tuple* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::std::string& items(int index) const;
  ::std::string* mutable_items(int index);
  void set_items(int index, const ::std::string& value);
  void set_items(int index, const char* value);
  void set_items(int index, const void* value, size_t size);
  ::std::string* add_items();
  void add_items(const ::std::string& value);
  void add_items(const char* value);
  void add_items(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& items() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_items();

  // @@protoc_insertion_point(class_scope:krpc.Tuple)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> items_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Tuple* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  inline Status* New() const { return New(NULL); }

  Status* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:krpc.Status)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Request

// required string service = 1;
inline bool Request::has_service() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_service() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_service() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_service() {
  service_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service();
}
inline const ::std::string& Request::service() const {
  // @@protoc_insertion_point(field_get:krpc.Request.service)
  return service_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_service(const ::std::string& value) {
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Request.service)
}
inline void Request::set_service(const char* value) {
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Request.service)
}
inline void Request::set_service(const char* value, size_t size) {
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Request.service)
}
inline ::std::string* Request::mutable_service() {
  set_has_service();
  // @@protoc_insertion_point(field_mutable:krpc.Request.service)
  return service_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_service() {
  clear_has_service();
  return service_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_service(::std::string* service) {
  if (service != NULL) {
    set_has_service();
  } else {
    clear_has_service();
  }
  service_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service);
  // @@protoc_insertion_point(field_set_allocated:krpc.Request.service)
}

// required string procedure = 2;
inline bool Request::has_procedure() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_procedure() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_procedure() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_procedure() {
  procedure_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_procedure();
}
inline const ::std::string& Request::procedure() const {
  // @@protoc_insertion_point(field_get:krpc.Request.procedure)
  return procedure_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_procedure(const ::std::string& value) {
  set_has_procedure();
  procedure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Request.procedure)
}
inline void Request::set_procedure(const char* value) {
  set_has_procedure();
  procedure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Request.procedure)
}
inline void Request::set_procedure(const char* value, size_t size) {
  set_has_procedure();
  procedure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Request.procedure)
}
inline ::std::string* Request::mutable_procedure() {
  set_has_procedure();
  // @@protoc_insertion_point(field_mutable:krpc.Request.procedure)
  return procedure_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_procedure() {
  clear_has_procedure();
  return procedure_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_procedure(::std::string* procedure) {
  if (procedure != NULL) {
    set_has_procedure();
  } else {
    clear_has_procedure();
  }
  procedure_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), procedure);
  // @@protoc_insertion_point(field_set_allocated:krpc.Request.procedure)
}

// repeated .krpc.Argument arguments = 3;
inline int Request::arguments_size() const {
  return arguments_.size();
}
inline void Request::clear_arguments() {
  arguments_.Clear();
}
inline const ::krpc::Argument& Request::arguments(int index) const {
  // @@protoc_insertion_point(field_get:krpc.Request.arguments)
  return arguments_.Get(index);
}
inline ::krpc::Argument* Request::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.Request.arguments)
  return arguments_.Mutable(index);
}
inline ::krpc::Argument* Request::add_arguments() {
  // @@protoc_insertion_point(field_add:krpc.Request.arguments)
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::Argument >&
Request::arguments() const {
  // @@protoc_insertion_point(field_list:krpc.Request.arguments)
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::Argument >*
Request::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:krpc.Request.arguments)
  return &arguments_;
}

// -------------------------------------------------------------------

// Argument

// required uint32 position = 1;
inline bool Argument::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Argument::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Argument::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Argument::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 Argument::position() const {
  // @@protoc_insertion_point(field_get:krpc.Argument.position)
  return position_;
}
inline void Argument::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:krpc.Argument.position)
}

// required bytes value = 2;
inline bool Argument::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Argument::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Argument::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Argument::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Argument::value() const {
  // @@protoc_insertion_point(field_get:krpc.Argument.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Argument.value)
}
inline void Argument::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Argument.value)
}
inline void Argument::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Argument.value)
}
inline ::std::string* Argument::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:krpc.Argument.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:krpc.Argument.value)
}

// -------------------------------------------------------------------

// Response

// required double time = 1;
inline bool Response::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double Response::time() const {
  // @@protoc_insertion_point(field_get:krpc.Response.time)
  return time_;
}
inline void Response::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:krpc.Response.time)
}

// optional string error = 2;
inline bool Response::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& Response::error() const {
  // @@protoc_insertion_point(field_get:krpc.Response.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Response.error)
}
inline void Response::set_error(const char* value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Response.error)
}
inline void Response::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Response.error)
}
inline ::std::string* Response::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:krpc.Response.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_error() {
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:krpc.Response.error)
}

// optional bytes return_value = 3;
inline bool Response::has_return_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_return_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_return_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_return_value() {
  return_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_return_value();
}
inline const ::std::string& Response::return_value() const {
  // @@protoc_insertion_point(field_get:krpc.Response.return_value)
  return return_value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_return_value(const ::std::string& value) {
  set_has_return_value();
  return_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Response.return_value)
}
inline void Response::set_return_value(const char* value) {
  set_has_return_value();
  return_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Response.return_value)
}
inline void Response::set_return_value(const void* value, size_t size) {
  set_has_return_value();
  return_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Response.return_value)
}
inline ::std::string* Response::mutable_return_value() {
  set_has_return_value();
  // @@protoc_insertion_point(field_mutable:krpc.Response.return_value)
  return return_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_return_value() {
  clear_has_return_value();
  return return_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_return_value(::std::string* return_value) {
  if (return_value != NULL) {
    set_has_return_value();
  } else {
    clear_has_return_value();
  }
  return_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), return_value);
  // @@protoc_insertion_point(field_set_allocated:krpc.Response.return_value)
}

// -------------------------------------------------------------------

// StreamMessage

// repeated .krpc.StreamResponse responses = 1;
inline int StreamMessage::responses_size() const {
  return responses_.size();
}
inline void StreamMessage::clear_responses() {
  responses_.Clear();
}
inline const ::krpc::StreamResponse& StreamMessage::responses(int index) const {
  // @@protoc_insertion_point(field_get:krpc.StreamMessage.responses)
  return responses_.Get(index);
}
inline ::krpc::StreamResponse* StreamMessage::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.StreamMessage.responses)
  return responses_.Mutable(index);
}
inline ::krpc::StreamResponse* StreamMessage::add_responses() {
  // @@protoc_insertion_point(field_add:krpc.StreamMessage.responses)
  return responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::StreamResponse >&
StreamMessage::responses() const {
  // @@protoc_insertion_point(field_list:krpc.StreamMessage.responses)
  return responses_;
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::StreamResponse >*
StreamMessage::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:krpc.StreamMessage.responses)
  return &responses_;
}

// -------------------------------------------------------------------

// StreamResponse

// required uint32 id = 1;
inline bool StreamResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamResponse::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 StreamResponse::id() const {
  // @@protoc_insertion_point(field_get:krpc.StreamResponse.id)
  return id_;
}
inline void StreamResponse::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:krpc.StreamResponse.id)
}

// required .krpc.Response response = 2;
inline bool StreamResponse::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamResponse::set_has_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamResponse::clear_has_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamResponse::clear_response() {
  if (response_ != NULL) response_->::krpc::Response::Clear();
  clear_has_response();
}
inline const ::krpc::Response& StreamResponse::response() const {
  // @@protoc_insertion_point(field_get:krpc.StreamResponse.response)
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::krpc::Response* StreamResponse::mutable_response() {
  set_has_response();
  if (response_ == NULL) {
    response_ = new ::krpc::Response;
  }
  // @@protoc_insertion_point(field_mutable:krpc.StreamResponse.response)
  return response_;
}
inline ::krpc::Response* StreamResponse::release_response() {
  clear_has_response();
  ::krpc::Response* temp = response_;
  response_ = NULL;
  return temp;
}
inline void StreamResponse::set_allocated_response(::krpc::Response* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
  // @@protoc_insertion_point(field_set_allocated:krpc.StreamResponse.response)
}

// -------------------------------------------------------------------

// Services

// repeated .krpc.Service services = 1;
inline int Services::services_size() const {
  return services_.size();
}
inline void Services::clear_services() {
  services_.Clear();
}
inline const ::krpc::Service& Services::services(int index) const {
  // @@protoc_insertion_point(field_get:krpc.Services.services)
  return services_.Get(index);
}
inline ::krpc::Service* Services::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.Services.services)
  return services_.Mutable(index);
}
inline ::krpc::Service* Services::add_services() {
  // @@protoc_insertion_point(field_add:krpc.Services.services)
  return services_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::Service >&
Services::services() const {
  // @@protoc_insertion_point(field_list:krpc.Services.services)
  return services_;
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::Service >*
Services::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:krpc.Services.services)
  return &services_;
}

// -------------------------------------------------------------------

// Service

// required string name = 1;
inline bool Service::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Service::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Service::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Service::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Service::name() const {
  // @@protoc_insertion_point(field_get:krpc.Service.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Service::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Service.name)
}
inline void Service::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Service.name)
}
inline void Service::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Service.name)
}
inline ::std::string* Service::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:krpc.Service.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Service::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Service::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.Service.name)
}

// repeated .krpc.Procedure procedures = 2;
inline int Service::procedures_size() const {
  return procedures_.size();
}
inline void Service::clear_procedures() {
  procedures_.Clear();
}
inline const ::krpc::Procedure& Service::procedures(int index) const {
  // @@protoc_insertion_point(field_get:krpc.Service.procedures)
  return procedures_.Get(index);
}
inline ::krpc::Procedure* Service::mutable_procedures(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.Service.procedures)
  return procedures_.Mutable(index);
}
inline ::krpc::Procedure* Service::add_procedures() {
  // @@protoc_insertion_point(field_add:krpc.Service.procedures)
  return procedures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::Procedure >&
Service::procedures() const {
  // @@protoc_insertion_point(field_list:krpc.Service.procedures)
  return procedures_;
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::Procedure >*
Service::mutable_procedures() {
  // @@protoc_insertion_point(field_mutable_list:krpc.Service.procedures)
  return &procedures_;
}

// repeated .krpc.Class classes = 3;
inline int Service::classes_size() const {
  return classes_.size();
}
inline void Service::clear_classes() {
  classes_.Clear();
}
inline const ::krpc::Class& Service::classes(int index) const {
  // @@protoc_insertion_point(field_get:krpc.Service.classes)
  return classes_.Get(index);
}
inline ::krpc::Class* Service::mutable_classes(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.Service.classes)
  return classes_.Mutable(index);
}
inline ::krpc::Class* Service::add_classes() {
  // @@protoc_insertion_point(field_add:krpc.Service.classes)
  return classes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::Class >&
Service::classes() const {
  // @@protoc_insertion_point(field_list:krpc.Service.classes)
  return classes_;
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::Class >*
Service::mutable_classes() {
  // @@protoc_insertion_point(field_mutable_list:krpc.Service.classes)
  return &classes_;
}

// repeated .krpc.Enumeration enumerations = 4;
inline int Service::enumerations_size() const {
  return enumerations_.size();
}
inline void Service::clear_enumerations() {
  enumerations_.Clear();
}
inline const ::krpc::Enumeration& Service::enumerations(int index) const {
  // @@protoc_insertion_point(field_get:krpc.Service.enumerations)
  return enumerations_.Get(index);
}
inline ::krpc::Enumeration* Service::mutable_enumerations(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.Service.enumerations)
  return enumerations_.Mutable(index);
}
inline ::krpc::Enumeration* Service::add_enumerations() {
  // @@protoc_insertion_point(field_add:krpc.Service.enumerations)
  return enumerations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::Enumeration >&
Service::enumerations() const {
  // @@protoc_insertion_point(field_list:krpc.Service.enumerations)
  return enumerations_;
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::Enumeration >*
Service::mutable_enumerations() {
  // @@protoc_insertion_point(field_mutable_list:krpc.Service.enumerations)
  return &enumerations_;
}

// -------------------------------------------------------------------

// Procedure

// required string name = 1;
inline bool Procedure::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Procedure::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Procedure::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Procedure::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Procedure::name() const {
  // @@protoc_insertion_point(field_get:krpc.Procedure.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Procedure::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Procedure.name)
}
inline void Procedure::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Procedure.name)
}
inline void Procedure::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Procedure.name)
}
inline ::std::string* Procedure::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:krpc.Procedure.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Procedure::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Procedure::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.Procedure.name)
}

// repeated .krpc.Parameter parameters = 2;
inline int Procedure::parameters_size() const {
  return parameters_.size();
}
inline void Procedure::clear_parameters() {
  parameters_.Clear();
}
inline const ::krpc::Parameter& Procedure::parameters(int index) const {
  // @@protoc_insertion_point(field_get:krpc.Procedure.parameters)
  return parameters_.Get(index);
}
inline ::krpc::Parameter* Procedure::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.Procedure.parameters)
  return parameters_.Mutable(index);
}
inline ::krpc::Parameter* Procedure::add_parameters() {
  // @@protoc_insertion_point(field_add:krpc.Procedure.parameters)
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::Parameter >&
Procedure::parameters() const {
  // @@protoc_insertion_point(field_list:krpc.Procedure.parameters)
  return parameters_;
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::Parameter >*
Procedure::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:krpc.Procedure.parameters)
  return &parameters_;
}

// optional string return_type = 3;
inline bool Procedure::has_return_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Procedure::set_has_return_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Procedure::clear_has_return_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Procedure::clear_return_type() {
  return_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_return_type();
}
inline const ::std::string& Procedure::return_type() const {
  // @@protoc_insertion_point(field_get:krpc.Procedure.return_type)
  return return_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Procedure::set_return_type(const ::std::string& value) {
  set_has_return_type();
  return_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Procedure.return_type)
}
inline void Procedure::set_return_type(const char* value) {
  set_has_return_type();
  return_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Procedure.return_type)
}
inline void Procedure::set_return_type(const char* value, size_t size) {
  set_has_return_type();
  return_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Procedure.return_type)
}
inline ::std::string* Procedure::mutable_return_type() {
  set_has_return_type();
  // @@protoc_insertion_point(field_mutable:krpc.Procedure.return_type)
  return return_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Procedure::release_return_type() {
  clear_has_return_type();
  return return_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Procedure::set_allocated_return_type(::std::string* return_type) {
  if (return_type != NULL) {
    set_has_return_type();
  } else {
    clear_has_return_type();
  }
  return_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), return_type);
  // @@protoc_insertion_point(field_set_allocated:krpc.Procedure.return_type)
}

// repeated string attributes = 4;
inline int Procedure::attributes_size() const {
  return attributes_.size();
}
inline void Procedure::clear_attributes() {
  attributes_.Clear();
}
inline const ::std::string& Procedure::attributes(int index) const {
  // @@protoc_insertion_point(field_get:krpc.Procedure.attributes)
  return attributes_.Get(index);
}
inline ::std::string* Procedure::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.Procedure.attributes)
  return attributes_.Mutable(index);
}
inline void Procedure::set_attributes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:krpc.Procedure.attributes)
  attributes_.Mutable(index)->assign(value);
}
inline void Procedure::set_attributes(int index, const char* value) {
  attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:krpc.Procedure.attributes)
}
inline void Procedure::set_attributes(int index, const char* value, size_t size) {
  attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:krpc.Procedure.attributes)
}
inline ::std::string* Procedure::add_attributes() {
  return attributes_.Add();
}
inline void Procedure::add_attributes(const ::std::string& value) {
  attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:krpc.Procedure.attributes)
}
inline void Procedure::add_attributes(const char* value) {
  attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:krpc.Procedure.attributes)
}
inline void Procedure::add_attributes(const char* value, size_t size) {
  attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:krpc.Procedure.attributes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Procedure::attributes() const {
  // @@protoc_insertion_point(field_list:krpc.Procedure.attributes)
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Procedure::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:krpc.Procedure.attributes)
  return &attributes_;
}

// -------------------------------------------------------------------

// Parameter

// required string name = 1;
inline bool Parameter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parameter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parameter::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Parameter::name() const {
  // @@protoc_insertion_point(field_get:krpc.Parameter.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parameter::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Parameter.name)
}
inline void Parameter::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Parameter.name)
}
inline void Parameter::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Parameter.name)
}
inline ::std::string* Parameter::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:krpc.Parameter.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Parameter::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parameter::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.Parameter.name)
}

// required string type = 2;
inline bool Parameter::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parameter::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parameter::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Parameter::type() const {
  // @@protoc_insertion_point(field_get:krpc.Parameter.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parameter::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Parameter.type)
}
inline void Parameter::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Parameter.type)
}
inline void Parameter::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Parameter.type)
}
inline ::std::string* Parameter::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:krpc.Parameter.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Parameter::release_type() {
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parameter::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:krpc.Parameter.type)
}

// optional bytes default_argument = 3;
inline bool Parameter::has_default_argument() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Parameter::set_has_default_argument() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Parameter::clear_has_default_argument() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Parameter::clear_default_argument() {
  default_argument_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_default_argument();
}
inline const ::std::string& Parameter::default_argument() const {
  // @@protoc_insertion_point(field_get:krpc.Parameter.default_argument)
  return default_argument_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parameter::set_default_argument(const ::std::string& value) {
  set_has_default_argument();
  default_argument_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Parameter.default_argument)
}
inline void Parameter::set_default_argument(const char* value) {
  set_has_default_argument();
  default_argument_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Parameter.default_argument)
}
inline void Parameter::set_default_argument(const void* value, size_t size) {
  set_has_default_argument();
  default_argument_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Parameter.default_argument)
}
inline ::std::string* Parameter::mutable_default_argument() {
  set_has_default_argument();
  // @@protoc_insertion_point(field_mutable:krpc.Parameter.default_argument)
  return default_argument_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Parameter::release_default_argument() {
  clear_has_default_argument();
  return default_argument_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parameter::set_allocated_default_argument(::std::string* default_argument) {
  if (default_argument != NULL) {
    set_has_default_argument();
  } else {
    clear_has_default_argument();
  }
  default_argument_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), default_argument);
  // @@protoc_insertion_point(field_set_allocated:krpc.Parameter.default_argument)
}

// -------------------------------------------------------------------

// Class

// required string name = 1;
inline bool Class::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Class::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Class::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Class::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Class::name() const {
  // @@protoc_insertion_point(field_get:krpc.Class.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Class::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Class.name)
}
inline void Class::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Class.name)
}
inline void Class::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Class.name)
}
inline ::std::string* Class::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:krpc.Class.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Class::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Class::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.Class.name)
}

// -------------------------------------------------------------------

// Enumeration

// required string name = 1;
inline bool Enumeration::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Enumeration::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Enumeration::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Enumeration::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Enumeration::name() const {
  // @@protoc_insertion_point(field_get:krpc.Enumeration.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Enumeration::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Enumeration.name)
}
inline void Enumeration::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Enumeration.name)
}
inline void Enumeration::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Enumeration.name)
}
inline ::std::string* Enumeration::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:krpc.Enumeration.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Enumeration::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Enumeration::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.Enumeration.name)
}

// repeated .krpc.EnumerationValue values = 2;
inline int Enumeration::values_size() const {
  return values_.size();
}
inline void Enumeration::clear_values() {
  values_.Clear();
}
inline const ::krpc::EnumerationValue& Enumeration::values(int index) const {
  // @@protoc_insertion_point(field_get:krpc.Enumeration.values)
  return values_.Get(index);
}
inline ::krpc::EnumerationValue* Enumeration::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.Enumeration.values)
  return values_.Mutable(index);
}
inline ::krpc::EnumerationValue* Enumeration::add_values() {
  // @@protoc_insertion_point(field_add:krpc.Enumeration.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::EnumerationValue >&
Enumeration::values() const {
  // @@protoc_insertion_point(field_list:krpc.Enumeration.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::EnumerationValue >*
Enumeration::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:krpc.Enumeration.values)
  return &values_;
}

// -------------------------------------------------------------------

// EnumerationValue

// required string name = 1;
inline bool EnumerationValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnumerationValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnumerationValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnumerationValue::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& EnumerationValue::name() const {
  // @@protoc_insertion_point(field_get:krpc.EnumerationValue.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumerationValue::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.EnumerationValue.name)
}
inline void EnumerationValue::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.EnumerationValue.name)
}
inline void EnumerationValue::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.EnumerationValue.name)
}
inline ::std::string* EnumerationValue::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:krpc.EnumerationValue.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnumerationValue::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumerationValue::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:krpc.EnumerationValue.name)
}

// required int32 value = 2;
inline bool EnumerationValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnumerationValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnumerationValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnumerationValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 EnumerationValue::value() const {
  // @@protoc_insertion_point(field_get:krpc.EnumerationValue.value)
  return value_;
}
inline void EnumerationValue::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:krpc.EnumerationValue.value)
}

// -------------------------------------------------------------------

// List

// repeated bytes items = 1;
inline int List::items_size() const {
  return items_.size();
}
inline void List::clear_items() {
  items_.Clear();
}
inline const ::std::string& List::items(int index) const {
  // @@protoc_insertion_point(field_get:krpc.List.items)
  return items_.Get(index);
}
inline ::std::string* List::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.List.items)
  return items_.Mutable(index);
}
inline void List::set_items(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:krpc.List.items)
  items_.Mutable(index)->assign(value);
}
inline void List::set_items(int index, const char* value) {
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:krpc.List.items)
}
inline void List::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:krpc.List.items)
}
inline ::std::string* List::add_items() {
  return items_.Add();
}
inline void List::add_items(const ::std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:krpc.List.items)
}
inline void List::add_items(const char* value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:krpc.List.items)
}
inline void List::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:krpc.List.items)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
List::items() const {
  // @@protoc_insertion_point(field_list:krpc.List.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
List::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:krpc.List.items)
  return &items_;
}

// -------------------------------------------------------------------

// Dictionary

// repeated .krpc.DictionaryEntry entries = 1;
inline int Dictionary::entries_size() const {
  return entries_.size();
}
inline void Dictionary::clear_entries() {
  entries_.Clear();
}
inline const ::krpc::DictionaryEntry& Dictionary::entries(int index) const {
  // @@protoc_insertion_point(field_get:krpc.Dictionary.entries)
  return entries_.Get(index);
}
inline ::krpc::DictionaryEntry* Dictionary::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.Dictionary.entries)
  return entries_.Mutable(index);
}
inline ::krpc::DictionaryEntry* Dictionary::add_entries() {
  // @@protoc_insertion_point(field_add:krpc.Dictionary.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::krpc::DictionaryEntry >&
Dictionary::entries() const {
  // @@protoc_insertion_point(field_list:krpc.Dictionary.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::krpc::DictionaryEntry >*
Dictionary::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:krpc.Dictionary.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// DictionaryEntry

// required bytes key = 1;
inline bool DictionaryEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DictionaryEntry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DictionaryEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DictionaryEntry::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& DictionaryEntry::key() const {
  // @@protoc_insertion_point(field_get:krpc.DictionaryEntry.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DictionaryEntry::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.DictionaryEntry.key)
}
inline void DictionaryEntry::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.DictionaryEntry.key)
}
inline void DictionaryEntry::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.DictionaryEntry.key)
}
inline ::std::string* DictionaryEntry::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:krpc.DictionaryEntry.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DictionaryEntry::release_key() {
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DictionaryEntry::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:krpc.DictionaryEntry.key)
}

// required bytes value = 2;
inline bool DictionaryEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DictionaryEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DictionaryEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DictionaryEntry::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& DictionaryEntry::value() const {
  // @@protoc_insertion_point(field_get:krpc.DictionaryEntry.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DictionaryEntry::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.DictionaryEntry.value)
}
inline void DictionaryEntry::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.DictionaryEntry.value)
}
inline void DictionaryEntry::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.DictionaryEntry.value)
}
inline ::std::string* DictionaryEntry::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:krpc.DictionaryEntry.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DictionaryEntry::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DictionaryEntry::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:krpc.DictionaryEntry.value)
}

// -------------------------------------------------------------------

// Set

// repeated bytes items = 1;
inline int Set::items_size() const {
  return items_.size();
}
inline void Set::clear_items() {
  items_.Clear();
}
inline const ::std::string& Set::items(int index) const {
  // @@protoc_insertion_point(field_get:krpc.Set.items)
  return items_.Get(index);
}
inline ::std::string* Set::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.Set.items)
  return items_.Mutable(index);
}
inline void Set::set_items(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:krpc.Set.items)
  items_.Mutable(index)->assign(value);
}
inline void Set::set_items(int index, const char* value) {
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:krpc.Set.items)
}
inline void Set::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:krpc.Set.items)
}
inline ::std::string* Set::add_items() {
  return items_.Add();
}
inline void Set::add_items(const ::std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:krpc.Set.items)
}
inline void Set::add_items(const char* value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:krpc.Set.items)
}
inline void Set::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:krpc.Set.items)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Set::items() const {
  // @@protoc_insertion_point(field_list:krpc.Set.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Set::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:krpc.Set.items)
  return &items_;
}

// -------------------------------------------------------------------

// Tuple

// repeated bytes items = 1;
inline int Tuple::items_size() const {
  return items_.size();
}
inline void Tuple::clear_items() {
  items_.Clear();
}
inline const ::std::string& Tuple::items(int index) const {
  // @@protoc_insertion_point(field_get:krpc.Tuple.items)
  return items_.Get(index);
}
inline ::std::string* Tuple::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.Tuple.items)
  return items_.Mutable(index);
}
inline void Tuple::set_items(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:krpc.Tuple.items)
  items_.Mutable(index)->assign(value);
}
inline void Tuple::set_items(int index, const char* value) {
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:krpc.Tuple.items)
}
inline void Tuple::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:krpc.Tuple.items)
}
inline ::std::string* Tuple::add_items() {
  return items_.Add();
}
inline void Tuple::add_items(const ::std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:krpc.Tuple.items)
}
inline void Tuple::add_items(const char* value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:krpc.Tuple.items)
}
inline void Tuple::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:krpc.Tuple.items)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Tuple::items() const {
  // @@protoc_insertion_point(field_list:krpc.Tuple.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Tuple::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:krpc.Tuple.items)
  return &items_;
}

// -------------------------------------------------------------------

// Status

// required string version = 1;
inline bool Status::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& Status::version() const {
  // @@protoc_insertion_point(field_get:krpc.Status.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Status::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:krpc.Status.version)
}
inline void Status::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:krpc.Status.version)
}
inline void Status::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:krpc.Status.version)
}
inline ::std::string* Status::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:krpc.Status.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Status::release_version() {
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Status::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:krpc.Status.version)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace krpc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_KRPC_2eproto__INCLUDED
